"""This module contains helper functions for the configuration."""
from __future__ import annotations

from collections import namedtuple
from enum import Enum
from pathlib import Path
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
import typed_settings as ts
import attr
import attrs


def parse_click_choice(
    name: str, enum_: type[Enum]
) -> Callable[[Enum | str | None], Enum | None]:
    """Validate the passed options for a :class:`click.Choice` option."""
    value_to_name = {enum_[name].value: name for name in enum_.__members__}

    def _parse(x: Enum | str | None) -> Enum | None:
        if x in [None, "None", "none"]:
            out = None
        elif isinstance(x, str) and x in value_to_name:
            out = enum_[value_to_name[x]]
        else:
            raise ValueError(f"'{name}' can only be one of {list(value_to_name)}.")
        return out

    return _parse


class ShowCapture(Enum):
    NO = "no"
    STDOUT = "stdout"
    STDERR = "stderr"
    ALL = "all"


@attr.s(kw_only=True)
class Configuration:
    """A class for holding multiple settings classes generated by typed-settings."""

    attrs = attr.ib(factory=dict, type=Dict[str, Any])
    settings_classes = attr.ib(factory=list, type=List[type])
    option = attr.ib(default=None, type=type)
    _consolidated = attr.ib(default=False, type=bool)
    _consolidated_error_msg = (
        "The configuration was consolidated. Use config.option to retrieve values."
    )

    def get(self, name: str):
        if self._consolidated:
            raise ValueError(self._consolidated_error_msg)

        if name in self.attrs:
            return self.attrs[name]
        else:
            for settings in self.settings_classes:
                if hasattr(settings, name):
                    return getattr(settings, name)
            else:
                raise KeyError(f"{self.__class__.__name__} has not attribute {name}.")

    def get_all(self, name: str):
        if self._consolidated:
            raise ValueError(self._consolidated_error_msg)

        out = []
        if name in self.attrs:
            out.append(self.attrs[name])
        for settings in self.settings_classes:
            if hasattr(settings, name):
                out.append(getattr(settings, name))
        return out

    def consolidate(self):
        all_settings = [self.attrs] + [
            attrs.asdict(settings) for settings in self.settings_classes
        ]
        merged = {k: v for s in reversed(all_settings) for k, v in s.items()}
        ordered = {k: merged[k] for k in sorted(merged)}
        options = namedtuple("options", ordered.keys())(**ordered)
        self.option = options
        self._consolidated = True


def merge_settings(
    paths: tuple[str, ...], main_settings: Any, command_settings: Any, command: str
) -> Any:
    """Merge main settings and command-specific settings."""
    config = Configuration(
        attrs={"paths": paths, "command": command},
        settings_classes=[command_settings, main_settings],
    )
    return config


def load_settings(command, attrs, file_loaders, converter):
    from _pytask.cli import cmd_to_settings

    main_settings = ts.load_settings(
        cmd_to_settings["main"], loaders=file_loaders, converter=converter
    )
    command_settings = ts.load_settings(
        cmd_to_settings[command], loaders=file_loaders, converter=converter
    )

    _check_if_all_values_are_valid_config_values(
        attrs, [main_settings, command_settings]
    )

    config = merge_settings(None, main_settings, command_settings, command)
    config.attrs = {**config.attrs, **attrs}

    return config


def _check_if_all_values_are_valid_config_values(attrs, classes):
    all_config_values = [k for c in classes for k in c.__dict__]
    not_parsed = {k: v for k, v in attrs.items() if k not in all_config_values}
    if not_parsed:
        raise ValueError(
            f"Some passed values are not valid setting values: {not_parsed}"
        )
